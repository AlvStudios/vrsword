<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mano y Espada con MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        #swordCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
    </style>
</head>
<body>
    <video id="video" autoplay></video>
    <canvas id="swordCanvas"></canvas>

    <!-- Incluir MediaPipe y TensorFlow.js desde un CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.5.1/dist/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.3.0/dist/tf.min.js"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('swordCanvas');
        const context = canvas.getContext('2d');

        let hands;

        async function init() {
            // Inicializar el video
            await startVideo();

            // Configuración del modelo de MediaPipe
            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.5.1/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            // Crear un contenedor de video para la cámara
            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        // Iniciar la cámara
        function startVideo() {
            return new Promise((resolve, reject) => {
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                    .then(stream => {
                        video.srcObject = stream;
                        video.onloadedmetadata = () => {
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            resolve();
                        };
                    })
                    .catch(err => reject(err));
            });
        }

        // Dibujar la espada
        function drawSword(x, y) {
            context.clearRect(0, 0, canvas.width, canvas.height);

            const swordWidth = 20;
            const swordHeight = 80;

            context.strokeStyle = 'silver';
            context.lineWidth = 5;
            context.beginPath();
            context.moveTo(x - swordWidth / 2, y - swordHeight / 2);
            context.lineTo(x + swordWidth / 2, y - swordHeight / 2);
            context.lineTo(x + swordWidth / 2, y + swordHeight / 2);
            context.lineTo(x - swordWidth / 2, y + swordHeight / 2);
            context.closePath();
            context.stroke();
        }

        // Manejar los resultados de MediaPipe
        function onResults(results) {
            if (results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const x = landmarks[9].x * canvas.width; // Indice de la muñeca
                const y = landmarks[9].y * canvas.height; // Indice de la muñeca

                drawSword(x, y);
            } else {
                drawSword(-100, -100); // Coloca la espada fuera de la vista
            }
        }

        init();
    </script>
</body>
</html>
