<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Espada en el Objeto Verde con Depuración</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #swordCanvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 2; }
    </style>
</head>
<body>
    <video id="video" autoplay muted playsinline></video>
    <canvas id="swordCanvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.3.0/dist/tf.min.js"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('swordCanvas');
        const context = canvas.getContext('2d');

        async function init() {
            await startVideo();

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            detectGreenObject();
        }

        function startVideo() {
            return new Promise((resolve, reject) => {
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                    .then(stream => {
                        video.srcObject = stream;
                        video.onloadedmetadata = () => {
                            video.play();
                            resolve();
                        };
                    })
                    .catch(err => {
                        console.error('Error accessing camera:', err);
                        reject(err);
                    });
            });
        }

        function drawSword(x, y) {
            context.clearRect(0, 0, canvas.width, canvas.height);

            const swordWidth = 20;
            const swordHeight = 80;

            context.strokeStyle = 'silver';
            context.lineWidth = 5;
            context.beginPath();
            context.moveTo(x - swordWidth / 2, y - swordHeight / 2);
            context.lineTo(x + swordWidth / 2, y - swordHeight / 2);
            context.lineTo(x + swordWidth / 2, y + swordHeight / 2);
            context.lineTo(x - swordWidth / 2, y + swordHeight / 2);
            context.closePath();
            context.stroke();
        }

        function drawDebugPoints(points) {
            context.fillStyle = 'red';
            points.forEach(point => {
                context.beginPath();
                context.arc(point.x, point.y, 5, 0, 2 * Math.PI);
                context.fill();
            });
        }

        function detectGreenObject() {
            const greenLower = [35, 50, 50]; // Ajusta estos valores según sea necesario
            const greenUpper = [85, 255, 255];

            function processFrame() {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
                const frame = context.getImageData(0, 0, canvas.width, canvas.height);
                const data = frame.data;

                let xSum = 0, ySum = 0, count = 0;
                const debugPoints = [];

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Convertir RGB a HSV
                    const [h, s, v] = rgbToHsv(r, g, b);

                    // Debug: Verificar valores HSV en la consola
                    // console.log(`HSV: ${h}, ${s}, ${v}`);

                    if (h >= greenLower[0] && h <= greenUpper[0] &&
                        s >= greenLower[1] && s <= greenUpper[1] &&
                        v >= greenLower[2] && v <= greenUpper[2]) {

                        const x = (i / 4) % canvas.width;
                        const y = Math.floor((i / 4) / canvas.width);
                        xSum += x;
                        ySum += y;
                        count++;

                        debugPoints.push({ x, y });
                    }
                }

                if (count > 0) {
                    const x = xSum / count;
                    const y = ySum / count;
                    drawSword(x, y);
                } else {
                    drawSword(-100, -100); // Coloca la espada fuera de la vista si no hay objeto verde
                }

                drawDebugPoints(debugPoints);

                requestAnimationFrame(processFrame);
            }

            processFrame();
        }

        function rgbToHsv(r, g, b) {
            r /= 255;
            g /= 255;
            b /= 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const delta = max - min;

            let h = 0;
            let s = max === 0 ? 0 : delta / max;
            let v = max;

            if (delta > 0) {
                if (max === r) {
                    h = (g - b) / delta + (g < b ? 6 : 0);
                } else if (max === g) {
                    h = (b - r) / delta + 2;
                } else if (max === b) {
                    h = (r - g) / delta + 4;
                }

                h /= 6;
            }

            return [h * 360, s * 100, v * 100];
        }

        init();
    </script>
</body>
</html>
